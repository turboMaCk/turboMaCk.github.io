---
title: Avoiding Pattern Matching
subtitle: Regaining open composability using refunctionalization
description: TBA
tags: elm, fp
---

I meant to write this post rather as a quick run through explanation of some of my ideas.
Anyway I'm going to start with rather more detailed explanation of what motivates
me to write this post in the first place and what is and what is not motivating me to write it.
If you're not interested in reading this you can [[][skip right to the content itself]].

Few days ago, my colleague [[https://twitter.com/janiczek][Martin Janiczek]] published a post on his blog called
[[http://martin.janiczek.cz/clanek/defunctionalization-in-elm/][Defunctionalization in Elm]]. In the post he talks about applying something that
was marketed as [[https://www.youtube.com/watch?v=vNwukfhsOME][The Best Refactoring You've Never Heard Of]] which is essentially
talk about refactoring between functions and data.

...TBA

The actual implementation is a bit more involved but for the purpose of
this post, we can simply mock it using types with these purposes:

- ~Flags~ is a type contained app configuration and contains data necessary for creating requests
- ~Store~ is a type in which we store data from server
- ~Config msg~ contains configuration for of the module (in reality it's record of functions, for simplification we're going to use a single function)
- ~Msg~ is a sum type of a different types of messages requests generate.

mocking all of those with types isomorphic to unit looks like this:

#+BEGIN_SRC elm
module Store exposing (..)

type Flags
    = Flags


type Store
    = Store


type alias Config msg =
    Msg -> msg


type Msg
    = Msg
#+END_SRC

This part of the Store module is not changing in between different implementations
but it's important as the other code we're about to write uses these types.

#+BEGIN_note
The fact that we're mocking with type wit dummy values will make the rest of the
code look a bit useless. You must believe me that all of this fits
into working implementation and has its purpose.
#+END_note

* Version with Sum Type and Pattern Matching

The /defunctionalized/ version (the one proposed by Martin) follows like this:

#+BEGIN_SRC elm
type alias FetchConfig a b =
    { update : a -> Store -> Store
    , done : Maybe b -> Cmd Msg
    }


fetch_ : FetchConfig a b -> Config msg -> Flags -> Store -> ( Store, Cmd msg )
fetch_ { done } toMsg Flags Store =
    ( Store, Cmd.map toMsg <| done Nothing )


type FetchAction
    = FetchFoo
    | FetchBar


fetch : FetchAction -> Config msg -> Flags -> Store -> ( Store, Cmd msg )
fetch action =
    case action of
        FetchFoo ->
            fetch_
                { update = always
                , done = always Cmd.none
                }

        FetchBar ->
            fetch_
                { update = always
                , done = always Cmd.none
                }


fetchMany : List FetchAction -> Config msg -> Flags -> Store -> ( Store, Cmd msg )
fetchMany actions config flags store =
    List.foldl
        (\action ( store_, cmd ) ->
            let
                ( newStore, newCmd ) =
                    fetch action config flags store_
            in
            ( newStore, Cmd.batch [ cmd, newCmd ] )
        )
        ( store, Cmd.none )
        actions
#+END_SRC

I would like to highlight some properties of this approach:

- ~FetchConfig msg~ is sort of intermediate structure, a product of all the data that differ for each type of request.
- ~fetch_~ is a helper function translating the ~FlagConfig msg~ to another (not visible in this example) API.
- ~FetchAction~ type is a point of coupling. Sum of all possible actions.
- ~fetch~ does just a branching for different actions.
- ~fetchMany~ folds actions and aggregates state and commands.

And this is how the usage looks of this API looks like:

#+BEGIN_SRC elm
module Main exposing ()

import Store exposing (Store(..), Flags(..))

type Msg
    = StoreMsg Store.Msg

caller : ( Store, Cmd Msg )
caller =
    Store.fetchMany [ Store.FetchFoo, Store.FetchBar ] StoreMsg Flags Store
#+END_SRC

The ~caller~ is a function that calls API of the Store module.

#+BEGIN_note
Seeing this I'm tempted to argue that putting the list argument as a last one
would be better in this case as then it would be possible to first configure the function by applying arguments
and than calling the function returned with different actions. Also in elm it would be possible to format
it a bit nicely with ~|>~ like

#+BEGIN_SRC elm
caller : ( Store, Cmd Msg )
caller =
    [ Store.FetchFoo, Store.FetchBar ]
      |> fetchMany configForA Flags Store
#+END_SRC

But in the reality we use yet another abstraction that expects the last value
to be state of the store so this API is better.
#+END_note

No matter how hard I try to look at the version with pattern matching over the sum type,
I don't see how it makes things simpler. In fact I think the only benefit gained of doing all of this
was just that in the process Martin reconstructed the functionality which helps with understanding it.

Data constructors are, in essence, just constants and functions.
The only thing which makes them different is that unlike regular constants and functions,
their names start with an uppercase and not a lowercase letter.
Well, there is another thing that makes them different.
*Pattern matching is basically branching over data constructors*
and thus is unique for cases when working with values other than functions and opaque aliases.

#+BEGIN_note
I think it's fair to say that arguing for API build around data constructors
is therefore same, or at least often same, as arguing for usage of pattern matching
in the actual implementation.
But there are some other (more or less) good arguments for using data over functions:

- Serialization (over wire)[fn:1]
- Equality, Ordering and other operations that can't work with functions[fn:2]
- Debugging is simpler with data (printing)[fn:3]
#+END_note

* Decoupling by Continuations

What seems like a problem to me is that this /defunctionalized/ API means our public API, the ~fetch~ function,
now couples all the individual cases together.

Let's see how it would look like if we would replace the ~FetchAction~ sum by individual constants.
Instead of having ~FetchAction~ type containing all the constants,
we're going to have bunch of constants of the same type.

First we can define some type without worrying about what this type means just yet.

#+BEGIN_SRC elm
type FetchAction =
    FetchAction


fetchFoo : FetchAction
fetchFoo = Debug.todo "implement me"


fetchBar : FetchAction
fetchBar = Debug.todo "implement me"
#+END_SRC

We expect these function to do everything so there is no need for ~fetch~ and ~fetch_~ helpers.

Now when we know how our API should look like, let's fill the implementation details.

Starting with ~FetchData~ which is itself just a function:

#+BEGIN_SRC elm
type FetchAction msg =
    FetchAction (Config msg -> Flags -> Store -> ( Store, Cmd msg ))
#+END_SRC

I'm wrapping function to a constructor for extra clarity to make it look more like a special value.

Martin also mentions in his post (quote):

#+BEGIN_QUOTE
And now, because the ~fetchMenu~ type annotation no longer contains any parameterized msg types,
it simplifies all types that touch it to the point where we don't need to Cmd.map the Msg at all!
That horrible piece of code becomes
#+END_QUOTE

And this is one the simplification that we will need to indeed give up.
We need this polymorphism to make API abstract enough.

The implementation against new ~FetchAction~ type might look like something like this.

#+BEGIN_SRC elm
fetchFoo : FetchAction msg
fetchFoo =
    FetchAction <|
        \toMsg Flags Store -> ( store, Cmd.map toMsg Cmd.none )


fetchBar : FetchAction msg
fetchBar =
    FetchAction <|
        \toMsg Flags Store -> ( store, Cmd.map toMsg Cmd.none )
#+END_SRC

#+BEGIN_note
In my experience some folks has a bit of a difficulty with thinking about the code that involves
working with functions. That is fine, everyone has certain bias and a different experience with things.
I think though that it is rather easy to find enough connection between the familiar and unfamiliar stuff
in most cases.

So what's the secret? Just forget about functions and data. Everything is just value which you can reduce
the problem space. When ever I have to deal with too many things at once I try to look for the pattern.
If I see some repeating part like ~Foo -> Bar -> a -> List a~ I know I can replace this thing in a head
with some place holder. And the only place where I really need to understand the detail of this is
only when I bridge the level of abstraction to say function which is concerned of actually constructing the final value.

This works well with full continuations or higher order functions in general.
The key is to understand how two different things can be viewed as the same thing at some level
of abstraction and then pick the right one for the level in which their differences do matter.

In context of this article the important thing to understand is that:

#+BEGIN_SRC elm
  type Fruit
      = Apple
      | Orange


  color : Fruit -> String
  color fruit =
      case fruit of
          Apple ->
              "green"

          Oragne ->
              "orange"
#+END_SRC

is on some level same as

#+BEGIN_SRC elm
  type alias Fruit =
      { color : String }


  apple : Fruit
  apple =
      { color = "green" }


  orange : Fruit
  orange =
      { color = "orange" }
#+END_SRC

But their are different on another level.
Defining fruit via sum crates a closed set of values.
Defining it by a product of properties creates an open set of values.

And even this is possible

#+BEGIN_SRC elm
  typ Fruit a =
      Fruit a


  getColor : (a -> String) -> Fruit a -> String
  getColor f (Fruit a) =
      f a


  type MyFruit
      = Apple
      | Orange


  type alias SpecialFruit =
      Fruit MyFruit


  specialFruitColor : SpecialFruit -> String
  specialFruitColor =
      (\myFruit ->
          case myFruit of
              Apple ->
                  "green"

              Orange ->
                  "orange"
      )
          |> getColor
#+END_SRC

Even though this last example seems odd for a simple case like this,
it makes the implementation even more opened than the second example.
This is essentially how type classes are often simulated in languages which
don't have them (like Elm).

#+END_note

In ~fetchMany~ we can just remove the function name ~fetch~ as the ~action~ argument
now becomes sort of the action itself. We're also boxing the function itself to
~FetchAction~ constructor so we're going to need to extract it.

~FetchAction~ type now has to be parametrized though the same way ~fetch~ function was in previous version.

#+BEGIN_SRC elm
fetchMany : List (FetchAction msg) -> Config msg -> Flags -> Store -> ( Store, Cmd msg )
fetchMany actions config flags store =
    List.foldl
        (\(FetchAction action) ( store_, cmd ) ->
            let
                ( newStore, newCmd ) =
                    action config flags store_
            in
            ( newStore, Cmd.batch [ cmd, newCmd ] )
        )
        ( store, Cmd.none )
        actions
#+END_SRC

This function is almost identical to the one from the "defunctionalized" version.
It just doesn't need to call any other function (~fetch~) so *if anything it's simpler*.

Look at the usage now:

#+BEGIN_SRC elm
module Main exposing ()

import Store exposing (Store(..), Flags(..))

type Msg
    = StoreMsg Store.Msg


storeConf : Store.Config Msg
storeConf =
    StoreMsg


caller : ( Store, Cmd Msg )
caller =
    fetchMany [ Store.fetchFoo, Store.fetchBar ] storeConf Flags Store
#+END_SRC

See the difference? It's just in ~Store.FetchFoo~ for "defunctionalized" version vs ~Store.fetchFoo~.
Is this more complicated in any way? I let you to be the judge.

* Extensibility

Since the second example doesn't contain tight coupling to the same sum type it can be quite easily composed even in Elm
where composition of data is much more restricted because of simple type system. For instance we can generalize
Store module in a way it can be extended with additional data and fetch functions like in this example:

Make store extensible record:

#+BEGIN_SRC elm
module Store exposing (..)


type Flags
    = Flags


type alias Store r =
    { r | x : () }


type alias Config msg =
    Msg -> msg


type Msg
    = Msg



-- New API


type FetchAction msg r
    = FetchAction (Config msg -> Flags -> Store r -> ( Store r, Cmd msg ))


fetchFoo : FetchAction msg r
fetchFoo =
    FetchAction <|
        \toMsg Flags store -> ( store, Cmd.map toMsg Cmd.none )


fetchBar : FetchAction msg r
fetchBar =
    FetchAction <|
        \toMsg Flags store -> ( store, Cmd.map toMsg Cmd.none )


fetchMany : List (FetchAction msg r) -> Config msg -> Flags -> Store r -> ( Store r, Cmd msg )
fetchMany actions config flags store =
    List.foldl
        (\(FetchAction action) ( store_, cmd ) ->
            let
                ( newStore, newCmd ) =
                    action config flags store_
            in
            ( newStore, Cmd.batch [ cmd, newCmd ] )
        )
        ( store, Cmd.none )
        actions
#+END_SRC

Extend the store with custom data in main module:

#+BEGIN_SRC elm
module Main exposing ()

import Store exposing (Store(..), Flags(..))


type Msg
    = StoreMsg Msg


type alias ExtendedStore =
    { x : (), y : () }


caller : ( ExtendedStore, Cmd Msg )
caller =
    fetchMany [ fetchFoo, fetchBar, fetchBaz ] StoreMsg Flags { x = (), y = () }


fetchBaz : FetchAction msg ExtendedStore
fetchBaz =
    Store.FetchAction <|
        \toMsg Flags store -> ( store, Cmd.map toMsg Cmd.none )
#+END_SRC

This would not be possible with previous example.

* Looking at Right Place

Martin ends his post with showing the screenshot of a part of final diff.
In this code section he simplifies a bit more involved code into an alias to Constructor.
This code was also highlighted in the PR.

I don't think this part has much to do with anything. Further more I think it's avoidable to do something
like this in any shape or form. There I believe the original code was done badly.

this is about module which on init requests some data. we can emit ~FetchAction~

#+BEGIN_SRC elm
init : (List (FetchAction msg) -> Cmd msg) -> ((), Cmd msg)
init fetch =
    ((), fetch [Store.fetchFoo, Store.fetchBar] )
#+END_SRC

now we don't need any special `Msg` in parent module. All we do is pass down the ~Store.fetchMany~ with applied arguments like Store and Flags.
Simple as that.

* Conclusion

Continuations are powerful thing and especially in language where magic you can do with the data being limited,
they might be the most composable gun in your arsenal. Sorry but function is the most powerful type of data you have.

Pattern matching generally leads to the coupling and usage of sum types leads to unnecessary branching.
In some cases it's unavoidable or even desirable to do such thing but it in fact hurts the code
in more cases than folks realize.
In some sense we're making a full circle back to the days where C APIs that are using integer arguments for changing it's behavior were.
We just have slightly more expressive tool to do so than integer is.

Some time ago I also created [[][elm-continue]] package which contains even more generalized abstraction
for working with continuations than we used here. That's probably something to check if you're willing
to go even slightly more crazy about patterns like this. I just must warn you that not everyone will like you for using it.

I honestly haven't enjoy writing this post much. First it might seem like a criticism, second I know a lot of people will disagree without even reading this far
and lastly I personally consider all what I wrote here as painfully obvious and therefor not that interesting.
The reason why I wrote this post anyway is the slight chance that someone will find this useful or interesting (looking at you Zdenko).

[fn:1] Some languages like [[http://unisonweb.org][Unison]] are able to serialize functions.
Unison specifically does so by sending the AST over the wire.
Even much simpler techniques comes in mind. Languages with ~eval~
(like most of the dynamic languages and almost all lisps (excluding clojure-script) has such function).
The primary concern here is a security and executing arbitrary code from some unknown source
is what is often called [[https://en.wikipedia.org/wiki/Arbitrary_code_execution][arbitrary code execution vunerability]]. Precisely because
of the security It's always good idea to close APIs exposed to untrusted 3rd parties.

[fn:2] Elm type system allows you to use equality operator (~(==)~) over any type
but blows up in runtime with functions. Languages with higher order polymorphism
or operator overloading won't are able to statically detect such cases and won't
allow you to use equality over functions. I'm not aware of language which in which
equality over function is possible but I believe in [[http://unisonweb.org][Unison]] it might be possible.

[fn:3] By definition it will still help you to just a see an intermediate value but that might
be enough for certain problems. Debugging is usually not an issue with step in debugging.
