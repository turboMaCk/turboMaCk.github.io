---
title: Avoiding Pattern Matching
subtitle: Regaining open composability using refunctionalization
description: TBA
tags: elm, fp
---

I meant to write this post rather as a quick run through explanation of some of my ideas.
Anyway I'm going to start with rather more detailed explanation of what motivates
me to write this post in the first place and what is and what is not motivating me to write it.
If you're not interested in reading this you can [[][skip right to the content itself]].

Few days ago, my colleague [[https://twitter.com/janiczek][Martin Janiczek]] published a post on his blog called
[[http://martin.janiczek.cz/clanek/defunctionalization-in-elm/][Defunctionalization in Elm]]. In the post he talks about applying something that
was marketed as [[https://www.youtube.com/watch?v=vNwukfhsOME][The Best Refactoring You've Never Heard Of]] which is essentially
talk about refactoring between functions and data.

...TBA

The actual real world implementation is a quite involved but for the purpose of
this post, we can simply mock it using types which are those:

- ~Flags~ is a type contained app configuration and contains data necessary for creating requests
- ~Store~ is a type in which we store data from server
- ~Config msg~ contains configuration for of the module (in reality it's record of functions, for simplification we're going to use a single function)
- ~Msg~ is a sum type of a different types of messages requests generate.

mocking all of those types with types isomorphic to unit looks like this:

#+BEGIN_SRC elm
module Store exposing (..)

type Flags
    = Flags


type Store
    = Store


type alias Config msg =
    Msg -> msg


type Msg
    = Msg
#+END_SRC

This part of the Store module is not changing between different implementations
but it's important as the other code we're about to write uses these types.

#+BEGIN_note
The fact that we're mocking with type wit dummy values will make the rest of the
code look a bit useless. You will must simply believe me that all of this fits
into working implementation.
#+END_note

* Version with sum type and pattern matching

The /defunctionalized/ version (the one proposed by Martin) follows as this:

#+BEGIN_SRC elm
type alias FetchConfig a b =
    { update : a -> Store -> Store
    , done : Maybe b -> Cmd Msg
    }


fetch_ : FetchConfig a b -> Config msg -> Flags -> Store -> ( Store, Cmd msg )
fetch_ { done } toMsg Flags Store =
    ( Store, Cmd.map toMsg <| done Nothing )


type FetchAction
    = FetchFoo
    | FetchBar


fetch : FetchAction -> Config msg -> Flags -> Store -> ( Store, Cmd msg )
fetch action =
    case action of
        FetchFoo ->
            fetch_
                { update = always
                , done = always Cmd.none
                }

        FetchBar ->
            fetch_
                { update = always
                , done = always Cmd.none
                }


fetchMany : List FetchAction -> Config msg -> Flags -> Store -> ( Store, Cmd msg )
fetchMany actions config flags store =
    List.foldl
        (\action ( store_, cmd ) ->
            let
                ( newStore, newCmd ) =
                    fetch action config flags store_
            in
            ( newStore, Cmd.batch [ cmd, newCmd ] )
        )
        ( store, Cmd.none )
        actions
#+END_SRC

I would highlight some properties of this approach to the problem:

- ~FetchConfig msg~ is sort of intermediate structure, a product of all the data different for each type of request.
- ~fetch_~ is a helper function translating the ~FlagConfig msg~ to another (not visible in this example) API.
- ~FetchAction~ type is a point of coupling. Sum of all possible actions.
- ~fetch~ does just a branching for different actions.
- ~fetchMany~ folds actions and aggregates state and Commands.

And this is how the usage looks of the API of this module looks like:

#+BEGIN_SRC elm
module Main exposing ()

import Store exposing (Store(..), Flags(..))

type Msg
    = StoreMsg Store.Msg

caller : ( Store, Cmd Msg )
caller =
    Store.fetchMany [ Store.FetchFoo, Store.FetchBar ] StoreMsg Flags Store
#+END_SRC

The ~caller~ is a function that calls API of the Store module.

#+BEGIN_note
I'm tempted to argue that putting the list argument as a last one
would be better in this case as then it would be possible to first configure the function by applying arguments
and than calling the function returned with different actions. Also in elm it would be possible to format
it a bit nicely with ~|>~ like

#+BEGIN_SRC elm
caller : ( Store, Cmd Msg )
caller =
    [ Store.FetchFoo, Store.FetchBar ]
      |> fetchMany configForA Flags Store
#+END_SRC

But in the reality we use yet another abstraction that expects the last value
of the stateful module to be a last argument and this in reality this API is just fine.
#+END_note

No matter how hard I try to look at the version with pattern matching over the sum type,
I don't see how this improves the API and even readability of this module.
Data constructors are, in essence, just constants or functions for cases they take arguments.
The only thing which makes them different is that unlike regular constant or functions is
that their names start with uppercase not lowercase letter.

So the data constructors are just like constants and functions?
Well there is another thing that makes them different.
*Pattern matching is basically branching over data constructors*
and thus is unique for case when working with data which are not functions.

#+BEGIN_note
I think it's fair to say that arguing for API build around data constructors
is therefore same or at least often same as arguing for usage of pattern matching
in the actual implementation.
But there are some other good arguments for using data over functions:

- Serialization (over wire)[fn:1]
- Equality and other properties that don't really work with functions[fn:2]
- Debugging is simpler with data (printing)[fn:3]
#+END_note

* Decoupling by Continuations

What seems like a problem to me though is that this means our public api, the ~fetch~ function,
now couples all the individual cases together.

Let's forget the last block of text and see how it would look like if we would replace the ~FetchAction~ sum by
individual constants. You can even think about it as a sort of reverse of types.
Instead of having ~FetchAction~ type containing all the constants, we're going to have bunch of constants of the same type.

First let's define the type, we don't need to worry about what this type is just yet.

#+BEGIN_SRC elm
type FetchAction =
    FetchAction


fetchFoo : FetchAction
fetchFoo = Debug.todo "implement me"


fetchBar : FetchAction
fetchBar = Debug.todo "implement me"
#+END_SRC

We expect these thing to do everything so we're not going to need any ~fetch~ or ~fetch_~ helper.

#+BEGIN_note
Besides we already have other abstraction in ~Store.Urils~ as mentioned above which is in fact the thing that
does the real work for us.
#+END_note

Now when we know how our API should look like, let's fill the boring implementation in place.

Starting with ~FetchData~ which is itself function.

#+BEGIN_SRC elm
type FetchAction msg =
    FetchAction (Config msg -> Flags -> Store -> ( Store, Cmd msg ))
#+END_SRC

I'm wrapping function to constructor for extra clarity that this is special function we
can consider as being constant value in some sort of more abstract model in our head.
In the end it's about first class functions so this function is value itself indeed.

#+BEGIN_QUOTE
And now, because the fetchMany type annotation no longer contains any parameterized msg types, it simplifies all types that touch it to the point where we don't need to Cmd.map the Msg at all! That horrible piece of code becomes:
#+END_QUOTE

Again sort of mocked implementation continues:

#+BEGIN_SRC elm
fetchFoo : FetchAction msg
fetchFoo =
    FetchAction <|
        \toMsg Flags Store -> ( store, Cmd.map toMsg Cmd.none )


fetchBar : FetchAction msg
fetchBar toMsg Flags store =
    FetchAction <|
        \toMsg Flags Store -> ( store, Cmd.map toMsg Cmd.none )
#+END_SRC

In ~fetchManu~ we can just remove the function name ~fetch~ as the ~action~ argument
now becomes sort of the action itself. We're also boxing the function itself to
~FetchAction~ constructor so we're going to need to extract it.

~FetchAction~ type now has to be parametrized though the same way ~fetch~ function was in previous version.

#+BEGIN_SRC elm
fetchMany : List (FetchAction msg) -> Config msg -> Flags -> Store -> ( Store, Cmd msg )
fetchMany actions config flags store =
    List.foldl
        (\(FetchAction action) ( store_, cmd ) ->
            let
                ( newStore, newCmd ) =
                    action config flags store_
            in
            ( newStore, Cmd.batch [ cmd, newCmd ] )
        )
        ( store, Cmd.none )
        actions
#+END_SRC

This function is almost identical to the one from the "defunctionalized" version.
It just doesn't need to call any other function (~fetch~) so *if anything it's simpler*.

Look at the usage now:

#+BEGIN_SRC elm
module Main exposing ()

import Store exposing (Store(..), Flags(..))

type Msg
    = StoreMsg Store.Msg


storeConf : Store.Config Msg
storeConf =
    StoreMsg


caller : ( Store, Cmd Msg )
caller =
    fetchMany [ Store.fetchFoo, Store.fetchBar ] storeConf Flags Store
#+END_SRC

See the difference? It's just in ~Store.FetchFoo~ for "defunctionalized" version vs ~Store.fetchFoo~.
Is this more complicated in any way? I let you to be the judge.

* Extensibility

Since the second example doesn't contain tight coupling to the same sum type it can be quite easily composed even in Elm
where composition of data is much more restricted because of simple type system. For instance we can generalize
Store module in a way it can be extended with additional data and fetch functions like in this example:

Make store extensible record:

#+BEGIN_SRC elm
module Store exposing (..)


type Flags
    = Flags


type alias Store r =
    { r | x : () }


type alias Config msg =
    Msg -> msg


type Msg
    = Msg



-- New API


type FetchAction msg r
    = FetchAction (Config msg -> Flags -> Store r -> ( Store r, Cmd msg ))


fetchFoo : FetchAction msg r
fetchFoo =
    FetchAction <|
        \toMsg Flags store -> ( store, Cmd.map toMsg Cmd.none )


fetchBar : FetchAction msg r
fetchBar =
    FetchAction <|
        \toMsg Flags store -> ( store, Cmd.map toMsg Cmd.none )


fetchMany : List (FetchAction msg r) -> Config msg -> Flags -> Store r -> ( Store r, Cmd msg )
fetchMany actions config flags store =
    List.foldl
        (\(FetchAction action) ( store_, cmd ) ->
            let
                ( newStore, newCmd ) =
                    action config flags store_
            in
            ( newStore, Cmd.batch [ cmd, newCmd ] )
        )
        ( store, Cmd.none )
        actions
#+END_SRC

Extend the store with custom data in main module:

#+BEGIN_SRC elm
module Main exposing ()

import Store exposing (Store(..), Flags(..))


type Msg
    = StoreMsg Msg


type alias ExtendedStore =
    { x : (), y : () }


caller : ( ExtendedStore, Cmd Msg )
caller =
    fetchMany [ fetchFoo, fetchBar, fetchBaz ] StoreMsg Flags { x = (), y = () }


fetchBaz : FetchAction msg ExtendedStore
fetchBaz =
    Store.FetchAction <|
        \toMsg Flags store -> ( store, Cmd.map toMsg Cmd.none )
#+END_SRC

This would not be possible with previous example.

* Looking at Right Place

Martin ends his post with showing the screenshot of a part of final diff.
In this code section he simplifies a bit more involved code into an alias to Constructor.
This code was also highlighted in the PR.

I don't think this part has much to do with anything. Further more I think it's avoidable to do something
like this in any shape or form. There I believe the original code was done badly.

this is about module which on init requests some data. we can emit ~FetchAction~

#+BEGIN_SRC elm
init : (List (FetchAction msg) -> Cmd msg) -> ((), Cmd msg)
init fetch =
    ((), fetch [Store.fetchFoo, Store.fetchBar] )
#+END_SRC

now we don't need any special `Msg` in parent module. All we do is pass down the ~Store.fetchMany~ with applied arguments like Store and Flags.
Simple as that.

* Conclusion

Continuations are powerful thing and especially in language where magic you can do with the data being limited,
they might be the most composable gun in your arsenal. Sorry but function is the most powerful type of data you have.

Pattern matching generally leads to the coupling and usage of sum types leads to unnecessary branching.
In some cases it's unavoidable or even desirable to do such thing but it in fact hurts the code
in more cases than folks realize.
In some sense we're making a full circle back to the days where C APIs that are using integer arguments for changing it's behavior were.
We just have slightly more expressive tool to do so than integer is.

Some time ago I also created [[][elm-continue]] package which contains even more generalized abstraction
for working with continuations than we used here. That's probably something to check if you're willing
to go even slightly more crazy about patterns like this. I just must warn you that not everyone will like you for using it.

I honestly haven't enjoy writing this post much. First it might seem like a criticism, second I know a lot of people will disagree without even reading this far
and lastly I personally consider all what I wrote here as painfully obvious and therefor not that interesting.
The reason why I wrote this post anyway is the slight chance that someone will find this useful or interesting (looking at you Zdenko).

[fn:1] Some languages like [[http://unisonweb.org][Unison]] are able to serialize functions.
Unison specifically does so by sending the AST over the wire.
Even much simpler techniques comes in mind. Languages with ~eval~
(like most of the dynamic languages and almost all lisps (excluding clojure-script) has such function).
The primary concern here is a security and executing arbitrary code from some unknown source
is what is often called [[https://en.wikipedia.org/wiki/Arbitrary_code_execution][arbitrary code execution vunerability]]. Precisely because
of the security It's always good idea to close APIs exposed to untrusted 3rd parties.

[fn:2] Elm type system allows you to use equality operator (~(==)~) over any type
but blows up in runtime with functions. Languages with higher order polymorphism
or operator overloading won't are able to statically detect such cases and won't
allow you to use equality over functions. I'm not aware of language which in which
equality over function is possible but I believe in [[http://unisonweb.org][Unison]] it might be possible.

[fn:3] By definition it will still help you to just a see an intermediate value but that might
be enough for certain problems. Debugging is usually not an issue with step in debugging.
