---
title: Anonymous types matter
subtitle: Anonymous type synonyms are great tool for opening your APIs.
description: In typed FP we sometimes tend to overuse closed design with opaque data. I'll try to make my case that in some situations we should actually go in exact opposite direction.
tags: functional-programming, elm, haskell, pure-script
---

So I recently released another Elm library. I wished to have library like this for a long
time but I was hoping someone else will come up the same design idea eventually.
Few weeks ago I finally found enough motivation to do the tedious work and code it.
Usually I don't write announcements to my releases but I think in this particular case
the design idea might be a bit controversial so I think it's worth the explanation.
I want to keep this post relatively general so it's not really an announcement post neither.
I just want to talk a bit about anonymous types.

This post will be primarily about Elm but I'm going to compare it to Haskell and PureScript as well.
It should be also simple to map these ideas to OCaml and F# (or any other language
with similar type system ML, Rust, Idris..) if that's your cup of tea.

* What is an Anonymous Type?

Term "/anonymous type/" is somewhat semi-technical. If you lookup [[https://en.wikipedia.org/wiki/Anonymous_type][Wikipedia article]] you find
some programming languages do actually include feature named "/anonymous types/" though.
So hopefully there are some similarities between these implementations.

#+BEGIN_QUOTE
Anonymous types are a feature of C# 3.0, Visual Basic .NET 9.0, Oxygene, Scala and Go that allows data types to encapsulate
a set of properties into a single object without having to first explicitly define a type.
#+END_QUOTE

If you look closer into how these features work you would find out that it
essentially allows programmer to construct ~record~ ~struct~ or ~object~ value (depending on language terminology and features)
without need to declare the corresponding type first.

For purposes of this post I'm going to generalize the definition to include all [[https://en.wikipedia.org/wiki/Product_type][product types]]
to potentially satisfy (or not) the condition of being anonymous.
In particular I mean that traditional tuple types from Haskell or ML are also anonymous types.

#+BEGIN_note
If I would attempt to define what /Anonymous Type/ is it the definition would be something like this:

*Anonymous type is a product type who's values can be constructed without explicit type declaration*.
Since all the information about the shape of product type can be infered at the time of construction
(which is not true about variant) type can be deduced directly from the value.
This should also already suggest that anonymity is provided by language itself not by its libraries.

This is not to be confused by type inference which is able to deduce the type of a value.
However type inference still requires the type to be declared, it just doesn't require
declaration of type on a value. For instance in this example Elm code:

#+BEGIN_SRC elm
type Object = Earth | Mars | Moon | Sun

destination = Mars
#+END_SRC

the type of ~destination~ is infered as ~Object~ but the declaration of ~Object~ type is required.

If you want to diff into much more advanced topic of anonymous variants check
[[http://comonad.com/reader/2008/the-cofree-comonad-and-the-expression-problem/][The Cofree Comonad and the Expression Problem]] by Edward Kmett.
#+END_note

* Anonymous Types in a Wild

I will be primary talking about records and tuples as I don't really want to attempt to solve [[https://en.wikipedia.org/wiki/Expression_problem][the expression problem]] here.
Perhaps I should also mention that *I'm not going to talk about extensible records or row polymorphism.*
This post it about plain simple boring records and tuples.

Since I don't want to assume deep familiarity with all or even just a single language I'm going to mention I will use
simple code examples for demonstrations. I've chosen Haskell Elm and PureScript as these
are good examples I'm familiar with myself.

#+BEGIN_note
Be aware that Elm has some (arguably confusing) naming inconsistency with Haskell and PureScript:

| Language   | Data Type | Unboxed Data Type | Type Synonym |
|------------+-----------+-------------------+--------------|
| Haskell    | data      | newtype           | type         |
| PureScript | data      | newtype           | type         |
| Elm        | type      | type (inferred)   | type alias   |
#+END_note

** Anonymous Tuples

Tuple is a sequence of elements. You can think about it as about struct which values are accessed by index.
It has fixed size and each value in a slot has specific type.

In examples below I'm also defining custom type just to make it obvious that tuple can hold any type of value
even the one which is not know to the standard library.

*** Haskell

This is the Haskell syntax for defining a tuple (pair in this case):

#+BEGIN_SRC haskell
newtype MyData = MyData { unMyData :: Int }

myPair = ("Foo", MyData 42)
#+END_SRC

If we run the ~ghci~ and load the module we can inspect the type of the value:

#+BEGIN_SRC haskell
λ :l Tuples.hs
[1 of 1] Compiling Main             ( Tuples.hs, interpreted )
Ok, one module loaded.
λ :t myPair
myPair :: ([Char], MyData)
#+END_SRC

This is the behavior we would expect from anonymous type.
We're given syntax to construct tuple in any module which results
in value of compatible type.

*** Elm

Elm has tuples very similar to the Haskell:

#+BEGIN_SRC elm
-- Elm requires module definition
module Tuples exposing (myPair)

type MyData = MyData Int

myPair = ("Foo", MyData 42)
#+END_SRC

To check the type we can fire repl again (use ~elm repl~ command. Be aware that presence of ~elm.json~ file required):

#+BEGIN_SRC elm
---- Elm 0.19.1 ----------------------------------------------------------------
Say :help for help and :exit to exit! More at <https://elm-lang.org/0.19.1/repl>
--------------------------------------------------------------------------------
> import Tuples exposing (..)
> myPair
("Foo",MyData 42) : ( String, MyData )
#+END_SRC

This is the same situation as with Haskell.

*** PureScript

PureScript is interesting as it does ship only with minimal language support
but without standard library. This is a design decision which makes
sense in wider context of PureScript's design.
But it also means that PureScript doesn't ship with support for tuples.
Tuples are provided by optional [[https://pursuit.purescript.org/packages/purescript-tuples/5.1.0][library]] instead.
there tuples are not build into the language which is one of the requirement
to make them truly anonymous as oppose to defined in terms of parameterized type.

I'm using [[https://github.com/purescript/spago][spago]] as a build tool for PS (which is sort of similar to [[https://docs.haskellstack.org][stack]] in Haskell world)
as because we need to manage dependencies in this case.

#+BEGIN_SRC haskell
module Tuples where

import Data.Tuple

newtype MyData = MyData Int

myPair = Tuple "Foo" (MyData 42)
#+END_SRC

Run ~spago repl~ to inspect the type:

#+BEGIN_SRC haskell
[info] Installation complete.
PSCi, version 0.13.6
Type :? for help

import Prelude

> import Tuples
> :t myPair
Tuple String MyData
#+END_SRC

So PureScript is clearly different. If we look into definition of
~Tuple~, we can see it's good old custom product type:

#+BEGIN_SRC haskell
data Tuple a b = Tuple a b
#+END_SRC

~Data.Tuple.Nested~ provides bunch of aliases and type and value operator (~/\~) for convenience.
We can also define our pair as following:

#+BEGIN_SRC haskell
myPair :: String /\ MyData
myPair = "Foo" /\ MyData 42
#+END_SRC

In fact this way of defining tuples is pretty close to the mathematical definition.


--- here

This is re-occurring thing with PureScript - it favores first class definitions over ad hoc syntax
even more than Elm (Lists being nice example where Haskell provides more sugar than other two.)
while having more first class constructs (type level operators, user definable value space operators - removed in Elm 0.19).

Anyway, since Tuples in pure-script are not first-class (language construct), we definitely can't considered them being anonymous.
Some of the aspect of this will perhaps become cleaner later. Anyway pure-script implementation also nicely demonstrates how it
is possible to sort of emulate absence of anonymous type in a laguage within user space:

- Define general custom type
- Provide functions to work with the general type
- Make it easy to define more specific types based on this general ones
- Make sure everybody is using the same definition (this definition) of general type to define their own

I also want to note that absence of built-in tuples in not much of a problem in PureScript in practice
as its record types and row polymorphism fills the purpose anyway. I personally still think that it's
nice to have first class tuples in some cases anyway.

** Records

Record is another example of product type which we might want to make anonymous. Lets look at the three languages
and their records:

*** Haskell

The lack of anonymous first class records [[https://duckduckgo.com/?t=ffab&q=haskell+records][is causing some headaches in Haskell for ages]]. Some folks
went even as far as staring to solve at least parts which are solvable in user space
(without compiler changes) in projects like [[https://hackage.haskell.org/package/record][Record]].

#+BEGIN_SRC haskell
data User = User { name :: String, age :: Int }
data Project = Project { name :: String, description :: String }
#+END_SRC

This fails with an error.

#+BEGIN_SRC shell
Records.hs:2:26: error:
    Multiple declarations of ‘name’
    Declared at: Records.hs:1:20
                 Records.hs:2:26
  |
2 | data Project = Project { name :: String, description :: String }
  |                          ^^^^
Failed, no modules loaded.
#+END_SRC

This is because Haskell records are just regular custom product types like ~data User = User String Int~
but with auto generated getter and setter functions. To fix this problem we need to ~:set -XDuplicateRecordFields~.

Anyway if we do so we loose ability to use getter and setter:

#+BEGIN_SRC shell
λ :t name

<interactive>:1:1: error:
    Ambiguous occurrence ‘name’
    It could refer to
       either the field ‘name’, defined at Records.hs:2:26
           or the field ‘name’, defined at Records.hs:1:20
#+END_SRC

So in order to make records usable one needs to allow some other extension like ~XRecordWildCards~.

These two extensions apparently became [[https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html][iconic duo]]. Since there is so much about how one can go about
dealing with Haskell records but I don't want to spent too much time on it there is a list of links for detailed articles:

- 24 Days of GHC Extensions: [[https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html][Record Wildcards]] by Ollie Charles
- [[https://kodimensional.dev/recordwildcards][The Power of RecordWildCards]] by Dmitrii Kovanikov
- GHC docs [[https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/disambiguate_record_fields.html][DisambiguateRecordFields]]
- [[https://hackage.haskell.org/package/record][Record]] by Nikita Volkov

Haskell's records are definitely not anonymous. Common usage of [[https://en.wikipedia.org/wiki/Hungarian_notation][Hungarian notation]] is a not so nice reminder
that Haskell of Haskell's relation to Microsoft research (don't take this joke too seriously).

*** Elm

In elm on the other hand we can easily do this:

#+BEGIN_SRC elm
module Records exposing (..)

type alias User = { name : String, age : Int }
type alias Project = { name : String, description : String }
#+END_SRC

As you can see these records are defined as synonyms (aliases) to already "existing" types,
not a type definition itself. We don't even need to declare them at all:

#+BEGIN_SRC elm
> foo = { asdf = "asdf", lkj = -1 }
{ asdf = "asdf", lkj = -1 }
    : { asdf : String, lkj : number }
#+END_SRC

Defining record aliases though gives are both ability to refer to the record by the synonym name
as well as function constructor for record values.

#+BEGIN_SRC elm
> User
<function> : String -> Int -> User
#+END_SRC

Further more elm gives us polymorphic getters and setters:

#+BEGIN_SRC elm
> .name
<function> : { b | name : a } -> a
#+END_SRC

~.name~ as well as ~foo.name~ will work with any records which has name filed of any type. This is much like a ~fst~ or ~Tupple.first~ function
but it also uses named rather than positional key!

#+BEGIN_note
Folks who dislike Apps Hungarian (like me) will find Elm's ~import qualified~ by default as well as records more elegant.
#+END_note

Elm's records are anonymous. Elm records are also so called /extensible records/.
[[https://elm.christmas/2018/19][You won't belive what these records can do!]] article by Jonas Berdal provides more information about this feature.

*** PureScript

Now for the PureScript:

#+BEGIN_SRC haskell
module Records where

type User = { name :: String, age :: Int }
type Project = { name :: String, description :: String }
#+END_SRC

Unlike Haskell (without language extensions) and like Elm, this code is perfectly fine.
Also like Elm we're just declaring synonyms to existing general record type here.

We of course don't need to declare synonyms unless we want to:

#+BEGIN_SRC haskell
> foo = { asdf : "asdf", lkj : -1 }
> :t foo
{ asdf :: String
, lkj :: Int
}
#+END_SRC

In PureScript aliases won't even give us function constructors like ~User : String -> Int -> User~.
Instead there is special syntax for declaring function constructor we can use even without synonyms:

#+BEGIN_SRC haskell
:t { foo : _, bar : _ }
forall t1 t2.
  t1
  -> t2
     -> { bar :: t2
        , foo :: t1
        }
#+END_SRC

We also don't get ~.name~ style functions so we need to use ~{record}.{field}~ syntax:

#+BEGIN_SRC haskell
> { name : "Jane Doe"}.name
"Jane Doe"
#+END_SRC

PureScript records has even more power provided by PS's row polymorphism.
You can check [[https://qiita.com/kimagure/items/ca229cb4ba76db0c24a8][Making Diffs of differently-typed Records in PureScript]] article by Justin Woo
if you're keen to learn more.

** Overview

So based on our findings we can compile this overview:

| Language   | Anonymous Tuples | Anonymous Records | Other Records Feature |
|------------+------------------+-------------------+-----------------------|
| Haskell    | yes              | no                | some via extensions   |
| Elm        | yes              | yes               | "extensibility"       |
| PureScript | no               | yes               | row polymorphism      |

* Why Anonymous Types Matter?

Anonymous types fill certain needs in software design pretty well.
This goes back to the open/closed principles [[/posts/2019-08-14-avoiding-pattern-matching-refunctionalization.html][I wrote about some time ago]] as well
as [[/posts/2020-02-21-value-space-decoding-for-aeson.html][Value Space Decoding For Aeson article]].

In all three languages we have whole spectrum of types which help to craft APIs
with the right properties. This is a comparison of a few points on this scale from
most closed to most open types

| Type           | Open/Closed     | Description                                                          |
|----------------+-----------------+----------------------------------------------------------------------|
| Opaque type    | strictly closed | Type can't be constructed and deconstructed outside of module        |
| Custom ADT | closed          | Type is defined in specific module we require to understand the type |
| Common ADT | almost opened   | Like custom ADT by known expected to universally available    |
| Anonymous type | opened          | Completely independent of it's definition, compatible by structure   |

Depending on the nature of the API or data different level of openness/closeness might be appropriate.

*** Opaque Types

Construction a Deconstruction and therefore all implementation details are available to
just a single (or limited number of) module. Useful for hiding details and internal invariants.

*** Custom ADT

Constructors are exposed but working with type requires importing the module and using its
definition (or synonyms for that definition). Useful for capturing semantics etc.

*** Common ADT

Same as [[#custom-adt][Custom ADT]] but expected to be available for variety of packages. This is especially
true about ADTs provided by standard library of official packages.

*** Anonymous Type

Synonyms on these doesn't require knowledge of the type definition or particular implementation.
Declared by structure, not by place of definition.

* Non-Empty List as Anonymous Type

I believe that, especially in Elm, it makes sense to use alias to anonymous type
for definition of [[https://hackage.haskell.org/package/semigroups-0.18.1/docs/Data-List-NonEmpty.html][non-empty list]] rather than ADT.
In particular I think the pair ~(a, List a)~ is a good representation for non empty
as the type itself is descriptive enough and positional nature of tuple fits
purpose of representing sequential data structure well.

I'm saying /especially in Elm/ because:

1. Unlike in Haskell, non-empty list is not part of elm/core
2. Unlike in PureScript there is not single implementation folks are expected to use.
3. It might be desirable for libraries to produce compatible type without dependency on a specific implementation (or any at all)
4. Functions and libraries which already produce compatible par would be compatible
5. Folks who don't like or are not familiar with abstraction can use elm/core functions to work with it anyway
6. Code generators from languages with default non-empty list can produce elm definition without picking implementation.

This doesn't mean there wouldn't be some benefits of similar implementation in Haskell as well,
[[https://twitter.com/fried_brice/status/1232773993507147776][some folks would like it]], I just think that in Elm in particular the benefits overweight the negatives.

1. Less semantically expressive constructor (in pattern matching)
2. Potentially encouraging even more fragmentation in implementations (or diversity, depends on where you stand).

(All of) That being said -- I've actually implemented this library and it's already available to
you to play with as [[https://package.elm-lang.org/packages/turboMaCk/non-empty-list-alias/latest/][turboMaCk/non-empty-list-alias]].

- [[https://package.elm-lang.org/packages/turboMaCk/non-empty-list-alias/latest/][Documentation]]
- [[https://github.com/turboMaCk/non-empty-list-alias][Repository]]

* Conclusion

I hope I was somewhat able to explain motivation behind this design
and perhaps even help to clear some intuition around different levels of power
we have in our type systems. I know this topic sounds mostly banal but I strongly belive
that solid understanding of basics goes a log way in understanding more advanced concepts
and helps with API design a ton.

I'm pretty sure there are and will always be some users who won't give up their semantically
more expressive definition of non-empty-list constructor and I think that's fine as long
as we all understand the trade-off. Luckily both alias to pair and custom ADTs
are isomorphic so it's just matter of practicality and nothing more.
