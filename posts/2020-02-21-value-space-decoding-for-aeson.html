<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="Description" content="My personal blog where I write mostly on topic of programming, especially function programming,
                   system design and other things related to what I've learned, wanted to share or complain about
                   within the discipline of software enginnering and informatics.">
    <title>Value Space Decoding for Aeson</title>
    <link rel="icon" type="image/png" href="../favicon.png" />
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
  </head>
  <body>
    <header class="page-header">
        <nav class="navigation">
            
                <a href="../">Home</a>
                <a href="../archive.html" class="active">B\og</a>
            
        </nav>
    </header>

    <main class="main-container">
      <div class="content">
        <h1>
          Value Space Decoding for Aeson
          
            <span class="subtitle">Implementation of combinators for JSON decoding in Haskell</span>
          
        </h1>

        
<div class="tags">
    Posted in: <a title="All pages tagged 'haskell'." href="../tags/haskell.html" rel="tag">haskell</a>, <a title="All pages tagged 'functional-programming'." href="../tags/functional-programming.html" rel="tag">functional-programming</a>.
</div>

<div class="info">
    Posted on February 21, 2020
    
</div>

<main id="content">
    <p>I’ve learned to like the way JSON decoding works in Elm<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.
I see some advantages of using combinators to decode values from JSONs.
In some situations, I would very much prefer
this style of decoding over type class instances used by <a href="https://hackage.haskell.org/package/aeson">Aeson</a>.</p>
<div class="updates">
<p>Since originally writing this post I’ve released full implementation
of this idea as a package to both Hackage and Stackage:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/aeson-combinators-0.0.1.0">aeson-combinators on Hackage</a></li>
<li><a href="https://github.com/commercialhaskell/stackage/pull/5216">PR to Stackage</a> - should become available soon</li>
<li><a href="https://github.com/turboMaCk/aeson-combinators">GitHub repository</a></li>
</ul>
</div>
<h2 id="conceptual-model-of-type-classes">Conceptual Model of Type Classes</h2>
<p>Type classes allow us to define that type is a member of larger groups of types (classes).
Or the other way around, to define classes of data types.
The important aspect, though, is that <strong>given specific type there is exactly
one way in which it can be made an instance of the class</strong>.
Even type classes like <code>Applicative</code> “<em>suffer</em>” from this limitation.
List <code>[a]</code> data type, for instance, has two completely valid, but different, implementations
of <code>Applicative</code> instance. Let me be clear, I’m not saying this is a huge problem in cases like <code>[a]</code>.
But this aspect will come back to haunt us, even more,
when we start using type classes for JSON decoding where it is even less clear
to know what we mean by “instance of <code>FromJSON</code>”.
<a href="http://comonad.com/reader/">Edward Kmett</a> had <a href="https://www.youtube.com/watch?v=hIZxTQP1ifo">a briliant talk about type classes in Boston Haskell Meetup</a> so don’t forget to check it out if you haven’t.</p>
<p>I hope I’ve managed to establish that with classes (like Aeson’s <code>FromJSON</code>) we’re essentially closing
the JSON decoding implementation over types.
I think that this, in many cases, is not a good model for translating data between different representations.
A much better way would be to allow for an arbitrary number of functions from JSON values to the same type.
It’s fair to assume that the same data type can be decoded from different JSONs structures
(problematic with type classes) as it is to assume that the same JSON structure
can be decoded to multiple data types (no problem with classes).</p>
<p>Because of this, it’s a common practice to define type wrappers around existing data types
just to make it possible to define “another” instance of <code>FromJSON</code> around the type.
While this solution works, I personally don’t find it satisfying.
To me, all these types are just unnecessary noise. I don’t like to have types
which are, in my opinion at least, not important in the conceptual model of my domain at all.</p>
<h2 id="solution">Solution</h2>
<p>What I would like to have is not a complete replacement for <code>FromJSON</code> class.
There are in fact cases where it makes sense to have a single definition
of a mapping between JSON and data type. So I still want to be able to define <code>FromJSON</code>
instance but I also want an option to define “decoders” not as an instance of a class of some type but as a value.</p>
<p>What I mean I that is to be able to do something like this (<code>ACD</code> being our library):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">Person</span> {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">      name ::</span> <span class="dt">Text</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> age  ::</span> <span class="dt">Int</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    } <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Person</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="ot">decodeEmbeded ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>decodeEmbeded path json <span class="ot">=</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    ACD.decode (ACD.at path ACD.auto) json</span></code></pre></div>
<p>Which can be used to extract <code>Person</code> embedded in
any JSON structure as following:</p>
<pre class="shell"><code>&gt;&gt;&gt; decodeEmbeded [&quot;data&quot;, &quot;person&quot;] &quot;{\&quot;data\&quot;:{\&quot;person\&quot;:{\&quot;name\&quot;:\&quot;Joe\&quot;,\&quot;age\&quot;:12}}}&quot;
Just (Person {name = &quot;Joe&quot;, age = 12})
</code></pre>
<p>Or I want to be able to define anonymous product (tuple) decoder:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Token</span> <span class="ot">=</span> <span class="dt">Text</span> <span class="co">-- using alias for simplicity</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">decodePersonWithToken ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Token</span>, <span class="dt">Person</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>decodePersonWithToken json <span class="ot">=</span> ACD.decode decoder json</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> decoder <span class="ot">=</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            (,) <span class="op">&lt;$&gt;</span> ACD.field <span class="st">&quot;token&quot;</span> ACD.auto</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>                <span class="op">&lt;*&gt;</span> ACD.field <span class="st">&quot;person&quot;</span> ACD.auto</span></code></pre></div>
<p>which works as following:</p>
<pre class="shell"><code>&gt;&gt;&gt; decodePersonWithToken &quot;{\&quot;person\&quot;:{\&quot;name\&quot;:\&quot;Joe\&quot;,\&quot;age\&quot;:12},\&quot;token\&quot;:\&quot;foo\&quot;}&quot;
Just (&quot;foo&quot;,Person {name = &quot;Joe&quot;, age = 12})
</code></pre>
<h2 id="implementation">Implementation</h2>
<p>The idea is to be able to define <code>Decoder a</code> type which is essentially just <code>parseJSON</code>
method from <code>FromJSON</code> class. Since we want to make this work with Aeson’s type classes
without introducing more than necessary overhead, we simply just wrap its member function <code>parseJSON</code> to a <code>newtype</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Decoder</span> a <span class="ot">=</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Decoder</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a)</span></code></pre></div>
<p>The simplest constructor of this type is from types which are member of <code>FromJSON</code> class:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">auto ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">Decoder</span> a</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>auto <span class="ot">=</span> <span class="dt">Decoder</span> parseJSON</span></code></pre></div>
<p>I don’t want to spent much time defining other constructors as this alone provides
enough but as an example this is how we can easily define constructor which turns any <code>Decoder a</code>
to <code>Decoder [a]</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">list ::</span> <span class="dt">Decoder</span> a <span class="ot">-&gt;</span> <span class="dt">Decoder</span> [a]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>list (<span class="dt">Decoder</span> d) <span class="ot">=</span> <span class="dt">Decoder</span> <span class="op">$</span> listParser d</span></code></pre></div>
<p>where <a href="https://hackage.haskell.org/package/aeson-1.4.6.0/docs/Data-Aeson-Types.html#v:listParser"><code>listParser</code></a> is a function provided by Aeson itself.</p>
<p>To make <code>Decoder</code> more useful we’re going to define instances of Functor, Applicative and Monad
which should be enough for providing most of important functionality.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Decoder</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Decoder</span> d) <span class="ot">=</span> <span class="dt">Decoder</span> <span class="op">$</span> <span class="fu">fmap</span> f <span class="op">.</span> d</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Decoder</span> <span class="kw">where</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> val <span class="ot">=</span> <span class="dt">Decoder</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> <span class="fu">pure</span> val</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Decoder</span> f') <span class="op">&lt;*&gt;</span> (<span class="dt">Decoder</span> d) <span class="ot">=</span> <span class="dt">Decoder</span> <span class="op">$</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    \val <span class="ot">-&gt;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        (\f <span class="ot">-&gt;</span> <span class="fu">fmap</span> f (d val)) <span class="op">=&lt;&lt;</span> f' val</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Decoder</span> <span class="kw">where</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Decoder</span> a) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Decoder</span> <span class="op">$</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    \val <span class="ot">-&gt;</span> <span class="kw">case</span> parse a val <span class="kw">of</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Success</span> v <span class="ot">-&gt;</span> <span class="kw">let</span> (<span class="dt">Decoder</span> res) <span class="ot">=</span> f v</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">in</span> res val</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>      _ <span class="ot">-&gt;</span> unexpected val</span></code></pre></div>
<p>And finally some combinators specific for JSON. We need a function then can extract value from
JSON filed. And then we can define another function for “drilling” a few fields deep into JSON Object.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">field ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Decoder</span> a <span class="ot">-&gt;</span> <span class="dt">Decoder</span> a</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>field t (<span class="dt">Decoder</span> d) <span class="ot">=</span> <span class="dt">Decoder</span> <span class="op">$</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  \val <span class="ot">-&gt;</span> <span class="kw">case</span> val <span class="kw">of</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Object</span> v <span class="ot">-&gt;</span> d <span class="op">=&lt;&lt;</span> v <span class="op">.:</span> t</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    _        <span class="ot">-&gt;</span> typeMismatch <span class="st">&quot;Object&quot;</span> val</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="ot">at ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Decoder</span> a <span class="ot">-&gt;</span> <span class="dt">Decoder</span> a</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>at path d <span class="ot">=</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldr</span> field d path</span></code></pre></div>
<p>Once again this is using functions already provided by Aeson.</p>
<p>Last step is to define new <a href="https://hackage.haskell.org/package/aeson-1.4.6.0/docs/Data-Aeson.html#v:decode">decode</a> which will work with <code>Decoder</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">decode ::</span> <span class="dt">Decoder</span> a <span class="ot">-&gt;</span> <span class="dt">LB.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>decode (<span class="dt">Decoder</span> d) <span class="ot">=</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  Parser.decodeWith ParserI.jsonEOF (parse d)</span></code></pre></div>
<p>All functions used here are provided by Aeson. <code>LB</code> is a lazy version of <code>ByteString</code>.</p>
<p>And this is all we need to make examples from section above working.</p>
<h2 id="elm-style-decoding">Elm Style Decoding</h2>
<p>It’s of course possible to use this <code>Decoder</code> type exclusively.
This makes writing Aeson decoders feel like elm/json.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">Person</span> {</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">      name ::</span> <span class="dt">Text</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> age  ::</span> <span class="dt">Int</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="ot">personDecoder ::</span> <span class="dt">Decoder</span> <span class="dt">Person</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>personDecoder <span class="ot">=</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Person</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;$&gt;</span> field <span class="st">&quot;name&quot;</span> auto</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;*&gt;</span> field <span class="st">&quot;age&quot;</span> auto</span></code></pre></div>
<h2 id="additional-resources">Additional Resources</h2>
<p>Full implementation of this Idea can be found in <a href="https://github.com/turboMaCk/aeson-combinators">this GitHub repository</a>.
Feel free to provide any feedback including criticism.
Just be aware that this is not published and is still missing some important bits.</p>
<p><a href="https://hackage.haskell.org/package/waargonaut">Waargonaut</a> package is Aeson alternative which has API similar to our <code>Decoder</code> approach
if you want to avoid whole Aeson.</p>
<p>While writing this post I’ve discovered that <a href="https://chris-martin.org/">Chris Martin</a> had a similar idea
implemented in <a href="https://hackage.haskell.org/package/aeson-decode-0.1.0.0/docs/AesonDecode.html">aeson-decode</a> package but the actual implementation uses <code>Value -&gt; Maybe a</code>
function similar to <a href="https://twitter.com/turbo_MaCk/status/1227247541336641536">my original prototype</a>.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>In fact I mean combination of <a href="https://package.elm-lang.org/packages/elm/json/latest/Json-Decode">elm/json</a> and <a href="https://package.elm-lang.org/packages/elm-community/json-extra/latest/Json-Decode-Extra">elm-comunity/json-extra</a> for Applicative “andMap”
or <a href="https://package.elm-lang.org/packages/NoRedInk/elm-json-decode-pipeline/latest/">NoRedInk/elm-json-decode-pipeline.</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</main>


<div class="reddit-discussion" id="discussion">
  <img src="../assets/reddit.png" alt="redit" class="reddit-logo">
  Since I'm not a fan of disqus or any other commenting system there is no disscusion under this post.<br>
  However I do like reddit as a platform so feel free to shout here:<br>
  <a href="https://www.reddit.com/r/haskell/comments/f7crdb/combinators_for_json_decoding">r/haskell/comments/f7crdb/combinators_for_json_decoding</a>
</div>


      </div>
      <footer id="footer">
        <a href="https://github.com/turboMaCk/turboMaCk.github.io">Source</a> available under BSD-3-Clause.<br>
        Content is published under <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br>
        Proudly powered by <a href="http://jaspervdj.be/hakyll">Hakyll</a>; Theme by Marek Fajkus<br>
        <a href="../rss.xml">RSS 2.0</a> compatible<br>
        This site is not tracking you.
      </footer>
    </main>

    <!-- MathJax is library for displaying math nicely -->
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
  </body>
</html>
